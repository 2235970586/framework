/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package com.fccfc.framework.task.api;

import org.apache.thrift.scheme.IScheme;
import org.apache.thrift.scheme.SchemeFactory;
import org.apache.thrift.scheme.StandardScheme;

import org.apache.thrift.scheme.TupleScheme;
import org.apache.thrift.protocol.TTupleProtocol;
import org.apache.thrift.protocol.TProtocolException;
import org.apache.thrift.EncodingUtils;
import org.apache.thrift.TException;
import org.apache.thrift.async.AsyncMethodCallback;
import org.apache.thrift.server.AbstractNonblockingServer.*;
import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import javax.annotation.Generated;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@SuppressWarnings({"cast", "rawtypes", "serial", "unchecked"})
@Generated(value = "Autogenerated by Thrift Compiler (0.9.2)", date = "2015-6-22")
public class Task implements org.apache.thrift.TBase<Task, Task._Fields>, java.io.Serializable, Cloneable, Comparable<Task> {
  private static final org.apache.thrift.protocol.TStruct STRUCT_DESC = new org.apache.thrift.protocol.TStruct("Task");

  private static final org.apache.thrift.protocol.TField TASK_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("taskId", org.apache.thrift.protocol.TType.I32, (short)1);
  private static final org.apache.thrift.protocol.TField TASK_NAME_FIELD_DESC = new org.apache.thrift.protocol.TField("taskName", org.apache.thrift.protocol.TType.STRING, (short)2);
  private static final org.apache.thrift.protocol.TField CLASS_NAME_FIELD_DESC = new org.apache.thrift.protocol.TField("className", org.apache.thrift.protocol.TType.STRING, (short)3);
  private static final org.apache.thrift.protocol.TField METHOD_FIELD_DESC = new org.apache.thrift.protocol.TField("method", org.apache.thrift.protocol.TType.STRING, (short)4);
  private static final org.apache.thrift.protocol.TField MODULE_CODE_FIELD_DESC = new org.apache.thrift.protocol.TField("moduleCode", org.apache.thrift.protocol.TType.STRING, (short)5);
  private static final org.apache.thrift.protocol.TField PRIORITY_FIELD_DESC = new org.apache.thrift.protocol.TField("priority", org.apache.thrift.protocol.TType.I32, (short)6);
  private static final org.apache.thrift.protocol.TField IS_CONCURRENT_FIELD_DESC = new org.apache.thrift.protocol.TField("isConcurrent", org.apache.thrift.protocol.TType.STRING, (short)7);
  private static final org.apache.thrift.protocol.TField TASK_STATE_FIELD_DESC = new org.apache.thrift.protocol.TField("taskState", org.apache.thrift.protocol.TType.STRING, (short)8);
  private static final org.apache.thrift.protocol.TField LAST_EXECUTE_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("lastExecuteTime", org.apache.thrift.protocol.TType.I64, (short)9);
  private static final org.apache.thrift.protocol.TField NEXT_EXCUTE_DATE_FIELD_DESC = new org.apache.thrift.protocol.TField("nextExcuteDate", org.apache.thrift.protocol.TType.I64, (short)10);
  private static final org.apache.thrift.protocol.TField OPERATOR_ID_FIELD_DESC = new org.apache.thrift.protocol.TField("operatorId", org.apache.thrift.protocol.TType.I32, (short)11);
  private static final org.apache.thrift.protocol.TField CREATE_TIME_FIELD_DESC = new org.apache.thrift.protocol.TField("createTime", org.apache.thrift.protocol.TType.I64, (short)12);

  private static final Map<Class<? extends IScheme>, SchemeFactory> schemes = new HashMap<Class<? extends IScheme>, SchemeFactory>();
  static {
    schemes.put(StandardScheme.class, new TaskStandardSchemeFactory());
    schemes.put(TupleScheme.class, new TaskTupleSchemeFactory());
  }

  public int taskId; // optional
  public String taskName; // required
  public String className; // required
  public String method; // required
  public String moduleCode; // optional
  public int priority; // optional
  public String isConcurrent; // optional
  public String taskState; // optional
  public long lastExecuteTime; // optional
  public long nextExcuteDate; // optional
  public int operatorId; // optional
  public long createTime; // optional

  /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
  public enum _Fields implements org.apache.thrift.TFieldIdEnum {
    TASK_ID((short)1, "taskId"),
    TASK_NAME((short)2, "taskName"),
    CLASS_NAME((short)3, "className"),
    METHOD((short)4, "method"),
    MODULE_CODE((short)5, "moduleCode"),
    PRIORITY((short)6, "priority"),
    IS_CONCURRENT((short)7, "isConcurrent"),
    TASK_STATE((short)8, "taskState"),
    LAST_EXECUTE_TIME((short)9, "lastExecuteTime"),
    NEXT_EXCUTE_DATE((short)10, "nextExcuteDate"),
    OPERATOR_ID((short)11, "operatorId"),
    CREATE_TIME((short)12, "createTime");

    private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

    static {
      for (_Fields field : EnumSet.allOf(_Fields.class)) {
        byName.put(field.getFieldName(), field);
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, or null if its not found.
     */
    public static _Fields findByThriftId(int fieldId) {
      switch(fieldId) {
        case 1: // TASK_ID
          return TASK_ID;
        case 2: // TASK_NAME
          return TASK_NAME;
        case 3: // CLASS_NAME
          return CLASS_NAME;
        case 4: // METHOD
          return METHOD;
        case 5: // MODULE_CODE
          return MODULE_CODE;
        case 6: // PRIORITY
          return PRIORITY;
        case 7: // IS_CONCURRENT
          return IS_CONCURRENT;
        case 8: // TASK_STATE
          return TASK_STATE;
        case 9: // LAST_EXECUTE_TIME
          return LAST_EXECUTE_TIME;
        case 10: // NEXT_EXCUTE_DATE
          return NEXT_EXCUTE_DATE;
        case 11: // OPERATOR_ID
          return OPERATOR_ID;
        case 12: // CREATE_TIME
          return CREATE_TIME;
        default:
          return null;
      }
    }

    /**
     * Find the _Fields constant that matches fieldId, throwing an exception
     * if it is not found.
     */
    public static _Fields findByThriftIdOrThrow(int fieldId) {
      _Fields fields = findByThriftId(fieldId);
      if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
      return fields;
    }

    /**
     * Find the _Fields constant that matches name, or null if its not found.
     */
    public static _Fields findByName(String name) {
      return byName.get(name);
    }

    private final short _thriftId;
    private final String _fieldName;

    _Fields(short thriftId, String fieldName) {
      _thriftId = thriftId;
      _fieldName = fieldName;
    }

    public short getThriftFieldId() {
      return _thriftId;
    }

    public String getFieldName() {
      return _fieldName;
    }
  }

  // isset id assignments
  private static final int __TASKID_ISSET_ID = 0;
  private static final int __PRIORITY_ISSET_ID = 1;
  private static final int __LASTEXECUTETIME_ISSET_ID = 2;
  private static final int __NEXTEXCUTEDATE_ISSET_ID = 3;
  private static final int __OPERATORID_ISSET_ID = 4;
  private static final int __CREATETIME_ISSET_ID = 5;
  private byte __isset_bitfield = 0;
  private static final _Fields optionals[] = {_Fields.TASK_ID,_Fields.MODULE_CODE,_Fields.PRIORITY,_Fields.IS_CONCURRENT,_Fields.TASK_STATE,_Fields.LAST_EXECUTE_TIME,_Fields.NEXT_EXCUTE_DATE,_Fields.OPERATOR_ID,_Fields.CREATE_TIME};
  public static final Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> metaDataMap;
  static {
    Map<_Fields, org.apache.thrift.meta_data.FieldMetaData> tmpMap = new EnumMap<_Fields, org.apache.thrift.meta_data.FieldMetaData>(_Fields.class);
    tmpMap.put(_Fields.TASK_ID, new org.apache.thrift.meta_data.FieldMetaData("taskId", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.TASK_NAME, new org.apache.thrift.meta_data.FieldMetaData("taskName", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.CLASS_NAME, new org.apache.thrift.meta_data.FieldMetaData("className", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.METHOD, new org.apache.thrift.meta_data.FieldMetaData("method", org.apache.thrift.TFieldRequirementType.REQUIRED, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.MODULE_CODE, new org.apache.thrift.meta_data.FieldMetaData("moduleCode", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.PRIORITY, new org.apache.thrift.meta_data.FieldMetaData("priority", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.IS_CONCURRENT, new org.apache.thrift.meta_data.FieldMetaData("isConcurrent", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.TASK_STATE, new org.apache.thrift.meta_data.FieldMetaData("taskState", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.STRING)));
    tmpMap.put(_Fields.LAST_EXECUTE_TIME, new org.apache.thrift.meta_data.FieldMetaData("lastExecuteTime", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.NEXT_EXCUTE_DATE, new org.apache.thrift.meta_data.FieldMetaData("nextExcuteDate", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    tmpMap.put(_Fields.OPERATOR_ID, new org.apache.thrift.meta_data.FieldMetaData("operatorId", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I32)));
    tmpMap.put(_Fields.CREATE_TIME, new org.apache.thrift.meta_data.FieldMetaData("createTime", org.apache.thrift.TFieldRequirementType.OPTIONAL, 
        new org.apache.thrift.meta_data.FieldValueMetaData(org.apache.thrift.protocol.TType.I64)));
    metaDataMap = Collections.unmodifiableMap(tmpMap);
    org.apache.thrift.meta_data.FieldMetaData.addStructMetaDataMap(Task.class, metaDataMap);
  }

  public Task() {
  }

  public Task(
    String taskName,
    String className,
    String method)
  {
    this();
    this.taskName = taskName;
    this.className = className;
    this.method = method;
  }

  /**
   * Performs a deep copy on <i>other</i>.
   */
  public Task(Task other) {
    __isset_bitfield = other.__isset_bitfield;
    this.taskId = other.taskId;
    if (other.isSetTaskName()) {
      this.taskName = other.taskName;
    }
    if (other.isSetClassName()) {
      this.className = other.className;
    }
    if (other.isSetMethod()) {
      this.method = other.method;
    }
    if (other.isSetModuleCode()) {
      this.moduleCode = other.moduleCode;
    }
    this.priority = other.priority;
    if (other.isSetIsConcurrent()) {
      this.isConcurrent = other.isConcurrent;
    }
    if (other.isSetTaskState()) {
      this.taskState = other.taskState;
    }
    this.lastExecuteTime = other.lastExecuteTime;
    this.nextExcuteDate = other.nextExcuteDate;
    this.operatorId = other.operatorId;
    this.createTime = other.createTime;
  }

  public Task deepCopy() {
    return new Task(this);
  }

  @Override
  public void clear() {
    setTaskIdIsSet(false);
    this.taskId = 0;
    this.taskName = null;
    this.className = null;
    this.method = null;
    this.moduleCode = null;
    setPriorityIsSet(false);
    this.priority = 0;
    this.isConcurrent = null;
    this.taskState = null;
    setLastExecuteTimeIsSet(false);
    this.lastExecuteTime = 0;
    setNextExcuteDateIsSet(false);
    this.nextExcuteDate = 0;
    setOperatorIdIsSet(false);
    this.operatorId = 0;
    setCreateTimeIsSet(false);
    this.createTime = 0;
  }

  public int getTaskId() {
    return this.taskId;
  }

  public Task setTaskId(int taskId) {
    this.taskId = taskId;
    setTaskIdIsSet(true);
    return this;
  }

  public void unsetTaskId() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __TASKID_ISSET_ID);
  }

  /** Returns true if field taskId is set (has been assigned a value) and false otherwise */
  public boolean isSetTaskId() {
    return EncodingUtils.testBit(__isset_bitfield, __TASKID_ISSET_ID);
  }

  public void setTaskIdIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __TASKID_ISSET_ID, value);
  }

  public String getTaskName() {
    return this.taskName;
  }

  public Task setTaskName(String taskName) {
    this.taskName = taskName;
    return this;
  }

  public void unsetTaskName() {
    this.taskName = null;
  }

  /** Returns true if field taskName is set (has been assigned a value) and false otherwise */
  public boolean isSetTaskName() {
    return this.taskName != null;
  }

  public void setTaskNameIsSet(boolean value) {
    if (!value) {
      this.taskName = null;
    }
  }

  public String getClassName() {
    return this.className;
  }

  public Task setClassName(String className) {
    this.className = className;
    return this;
  }

  public void unsetClassName() {
    this.className = null;
  }

  /** Returns true if field className is set (has been assigned a value) and false otherwise */
  public boolean isSetClassName() {
    return this.className != null;
  }

  public void setClassNameIsSet(boolean value) {
    if (!value) {
      this.className = null;
    }
  }

  public String getMethod() {
    return this.method;
  }

  public Task setMethod(String method) {
    this.method = method;
    return this;
  }

  public void unsetMethod() {
    this.method = null;
  }

  /** Returns true if field method is set (has been assigned a value) and false otherwise */
  public boolean isSetMethod() {
    return this.method != null;
  }

  public void setMethodIsSet(boolean value) {
    if (!value) {
      this.method = null;
    }
  }

  public String getModuleCode() {
    return this.moduleCode;
  }

  public Task setModuleCode(String moduleCode) {
    this.moduleCode = moduleCode;
    return this;
  }

  public void unsetModuleCode() {
    this.moduleCode = null;
  }

  /** Returns true if field moduleCode is set (has been assigned a value) and false otherwise */
  public boolean isSetModuleCode() {
    return this.moduleCode != null;
  }

  public void setModuleCodeIsSet(boolean value) {
    if (!value) {
      this.moduleCode = null;
    }
  }

  public int getPriority() {
    return this.priority;
  }

  public Task setPriority(int priority) {
    this.priority = priority;
    setPriorityIsSet(true);
    return this;
  }

  public void unsetPriority() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __PRIORITY_ISSET_ID);
  }

  /** Returns true if field priority is set (has been assigned a value) and false otherwise */
  public boolean isSetPriority() {
    return EncodingUtils.testBit(__isset_bitfield, __PRIORITY_ISSET_ID);
  }

  public void setPriorityIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __PRIORITY_ISSET_ID, value);
  }

  public String getIsConcurrent() {
    return this.isConcurrent;
  }

  public Task setIsConcurrent(String isConcurrent) {
    this.isConcurrent = isConcurrent;
    return this;
  }

  public void unsetIsConcurrent() {
    this.isConcurrent = null;
  }

  /** Returns true if field isConcurrent is set (has been assigned a value) and false otherwise */
  public boolean isSetIsConcurrent() {
    return this.isConcurrent != null;
  }

  public void setIsConcurrentIsSet(boolean value) {
    if (!value) {
      this.isConcurrent = null;
    }
  }

  public String getTaskState() {
    return this.taskState;
  }

  public Task setTaskState(String taskState) {
    this.taskState = taskState;
    return this;
  }

  public void unsetTaskState() {
    this.taskState = null;
  }

  /** Returns true if field taskState is set (has been assigned a value) and false otherwise */
  public boolean isSetTaskState() {
    return this.taskState != null;
  }

  public void setTaskStateIsSet(boolean value) {
    if (!value) {
      this.taskState = null;
    }
  }

  public long getLastExecuteTime() {
    return this.lastExecuteTime;
  }

  public Task setLastExecuteTime(long lastExecuteTime) {
    this.lastExecuteTime = lastExecuteTime;
    setLastExecuteTimeIsSet(true);
    return this;
  }

  public void unsetLastExecuteTime() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __LASTEXECUTETIME_ISSET_ID);
  }

  /** Returns true if field lastExecuteTime is set (has been assigned a value) and false otherwise */
  public boolean isSetLastExecuteTime() {
    return EncodingUtils.testBit(__isset_bitfield, __LASTEXECUTETIME_ISSET_ID);
  }

  public void setLastExecuteTimeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __LASTEXECUTETIME_ISSET_ID, value);
  }

  public long getNextExcuteDate() {
    return this.nextExcuteDate;
  }

  public Task setNextExcuteDate(long nextExcuteDate) {
    this.nextExcuteDate = nextExcuteDate;
    setNextExcuteDateIsSet(true);
    return this;
  }

  public void unsetNextExcuteDate() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __NEXTEXCUTEDATE_ISSET_ID);
  }

  /** Returns true if field nextExcuteDate is set (has been assigned a value) and false otherwise */
  public boolean isSetNextExcuteDate() {
    return EncodingUtils.testBit(__isset_bitfield, __NEXTEXCUTEDATE_ISSET_ID);
  }

  public void setNextExcuteDateIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __NEXTEXCUTEDATE_ISSET_ID, value);
  }

  public int getOperatorId() {
    return this.operatorId;
  }

  public Task setOperatorId(int operatorId) {
    this.operatorId = operatorId;
    setOperatorIdIsSet(true);
    return this;
  }

  public void unsetOperatorId() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __OPERATORID_ISSET_ID);
  }

  /** Returns true if field operatorId is set (has been assigned a value) and false otherwise */
  public boolean isSetOperatorId() {
    return EncodingUtils.testBit(__isset_bitfield, __OPERATORID_ISSET_ID);
  }

  public void setOperatorIdIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __OPERATORID_ISSET_ID, value);
  }

  public long getCreateTime() {
    return this.createTime;
  }

  public Task setCreateTime(long createTime) {
    this.createTime = createTime;
    setCreateTimeIsSet(true);
    return this;
  }

  public void unsetCreateTime() {
    __isset_bitfield = EncodingUtils.clearBit(__isset_bitfield, __CREATETIME_ISSET_ID);
  }

  /** Returns true if field createTime is set (has been assigned a value) and false otherwise */
  public boolean isSetCreateTime() {
    return EncodingUtils.testBit(__isset_bitfield, __CREATETIME_ISSET_ID);
  }

  public void setCreateTimeIsSet(boolean value) {
    __isset_bitfield = EncodingUtils.setBit(__isset_bitfield, __CREATETIME_ISSET_ID, value);
  }

  public void setFieldValue(_Fields field, Object value) {
    switch (field) {
    case TASK_ID:
      if (value == null) {
        unsetTaskId();
      } else {
        setTaskId((Integer)value);
      }
      break;

    case TASK_NAME:
      if (value == null) {
        unsetTaskName();
      } else {
        setTaskName((String)value);
      }
      break;

    case CLASS_NAME:
      if (value == null) {
        unsetClassName();
      } else {
        setClassName((String)value);
      }
      break;

    case METHOD:
      if (value == null) {
        unsetMethod();
      } else {
        setMethod((String)value);
      }
      break;

    case MODULE_CODE:
      if (value == null) {
        unsetModuleCode();
      } else {
        setModuleCode((String)value);
      }
      break;

    case PRIORITY:
      if (value == null) {
        unsetPriority();
      } else {
        setPriority((Integer)value);
      }
      break;

    case IS_CONCURRENT:
      if (value == null) {
        unsetIsConcurrent();
      } else {
        setIsConcurrent((String)value);
      }
      break;

    case TASK_STATE:
      if (value == null) {
        unsetTaskState();
      } else {
        setTaskState((String)value);
      }
      break;

    case LAST_EXECUTE_TIME:
      if (value == null) {
        unsetLastExecuteTime();
      } else {
        setLastExecuteTime((Long)value);
      }
      break;

    case NEXT_EXCUTE_DATE:
      if (value == null) {
        unsetNextExcuteDate();
      } else {
        setNextExcuteDate((Long)value);
      }
      break;

    case OPERATOR_ID:
      if (value == null) {
        unsetOperatorId();
      } else {
        setOperatorId((Integer)value);
      }
      break;

    case CREATE_TIME:
      if (value == null) {
        unsetCreateTime();
      } else {
        setCreateTime((Long)value);
      }
      break;

    }
  }

  public Object getFieldValue(_Fields field) {
    switch (field) {
    case TASK_ID:
      return Integer.valueOf(getTaskId());

    case TASK_NAME:
      return getTaskName();

    case CLASS_NAME:
      return getClassName();

    case METHOD:
      return getMethod();

    case MODULE_CODE:
      return getModuleCode();

    case PRIORITY:
      return Integer.valueOf(getPriority());

    case IS_CONCURRENT:
      return getIsConcurrent();

    case TASK_STATE:
      return getTaskState();

    case LAST_EXECUTE_TIME:
      return Long.valueOf(getLastExecuteTime());

    case NEXT_EXCUTE_DATE:
      return Long.valueOf(getNextExcuteDate());

    case OPERATOR_ID:
      return Integer.valueOf(getOperatorId());

    case CREATE_TIME:
      return Long.valueOf(getCreateTime());

    }
    throw new IllegalStateException();
  }

  /** Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise */
  public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case TASK_ID:
      return isSetTaskId();
    case TASK_NAME:
      return isSetTaskName();
    case CLASS_NAME:
      return isSetClassName();
    case METHOD:
      return isSetMethod();
    case MODULE_CODE:
      return isSetModuleCode();
    case PRIORITY:
      return isSetPriority();
    case IS_CONCURRENT:
      return isSetIsConcurrent();
    case TASK_STATE:
      return isSetTaskState();
    case LAST_EXECUTE_TIME:
      return isSetLastExecuteTime();
    case NEXT_EXCUTE_DATE:
      return isSetNextExcuteDate();
    case OPERATOR_ID:
      return isSetOperatorId();
    case CREATE_TIME:
      return isSetCreateTime();
    }
    throw new IllegalStateException();
  }

  @Override
  public boolean equals(Object that) {
    if (that == null)
      return false;
    if (that instanceof Task)
      return this.equals((Task)that);
    return false;
  }

  public boolean equals(Task that) {
    if (that == null)
      return false;

    boolean this_present_taskId = true && this.isSetTaskId();
    boolean that_present_taskId = true && that.isSetTaskId();
    if (this_present_taskId || that_present_taskId) {
      if (!(this_present_taskId && that_present_taskId))
        return false;
      if (this.taskId != that.taskId)
        return false;
    }

    boolean this_present_taskName = true && this.isSetTaskName();
    boolean that_present_taskName = true && that.isSetTaskName();
    if (this_present_taskName || that_present_taskName) {
      if (!(this_present_taskName && that_present_taskName))
        return false;
      if (!this.taskName.equals(that.taskName))
        return false;
    }

    boolean this_present_className = true && this.isSetClassName();
    boolean that_present_className = true && that.isSetClassName();
    if (this_present_className || that_present_className) {
      if (!(this_present_className && that_present_className))
        return false;
      if (!this.className.equals(that.className))
        return false;
    }

    boolean this_present_method = true && this.isSetMethod();
    boolean that_present_method = true && that.isSetMethod();
    if (this_present_method || that_present_method) {
      if (!(this_present_method && that_present_method))
        return false;
      if (!this.method.equals(that.method))
        return false;
    }

    boolean this_present_moduleCode = true && this.isSetModuleCode();
    boolean that_present_moduleCode = true && that.isSetModuleCode();
    if (this_present_moduleCode || that_present_moduleCode) {
      if (!(this_present_moduleCode && that_present_moduleCode))
        return false;
      if (!this.moduleCode.equals(that.moduleCode))
        return false;
    }

    boolean this_present_priority = true && this.isSetPriority();
    boolean that_present_priority = true && that.isSetPriority();
    if (this_present_priority || that_present_priority) {
      if (!(this_present_priority && that_present_priority))
        return false;
      if (this.priority != that.priority)
        return false;
    }

    boolean this_present_isConcurrent = true && this.isSetIsConcurrent();
    boolean that_present_isConcurrent = true && that.isSetIsConcurrent();
    if (this_present_isConcurrent || that_present_isConcurrent) {
      if (!(this_present_isConcurrent && that_present_isConcurrent))
        return false;
      if (!this.isConcurrent.equals(that.isConcurrent))
        return false;
    }

    boolean this_present_taskState = true && this.isSetTaskState();
    boolean that_present_taskState = true && that.isSetTaskState();
    if (this_present_taskState || that_present_taskState) {
      if (!(this_present_taskState && that_present_taskState))
        return false;
      if (!this.taskState.equals(that.taskState))
        return false;
    }

    boolean this_present_lastExecuteTime = true && this.isSetLastExecuteTime();
    boolean that_present_lastExecuteTime = true && that.isSetLastExecuteTime();
    if (this_present_lastExecuteTime || that_present_lastExecuteTime) {
      if (!(this_present_lastExecuteTime && that_present_lastExecuteTime))
        return false;
      if (this.lastExecuteTime != that.lastExecuteTime)
        return false;
    }

    boolean this_present_nextExcuteDate = true && this.isSetNextExcuteDate();
    boolean that_present_nextExcuteDate = true && that.isSetNextExcuteDate();
    if (this_present_nextExcuteDate || that_present_nextExcuteDate) {
      if (!(this_present_nextExcuteDate && that_present_nextExcuteDate))
        return false;
      if (this.nextExcuteDate != that.nextExcuteDate)
        return false;
    }

    boolean this_present_operatorId = true && this.isSetOperatorId();
    boolean that_present_operatorId = true && that.isSetOperatorId();
    if (this_present_operatorId || that_present_operatorId) {
      if (!(this_present_operatorId && that_present_operatorId))
        return false;
      if (this.operatorId != that.operatorId)
        return false;
    }

    boolean this_present_createTime = true && this.isSetCreateTime();
    boolean that_present_createTime = true && that.isSetCreateTime();
    if (this_present_createTime || that_present_createTime) {
      if (!(this_present_createTime && that_present_createTime))
        return false;
      if (this.createTime != that.createTime)
        return false;
    }

    return true;
  }

  @Override
  public int hashCode() {
    List<Object> list = new ArrayList<Object>();

    boolean present_taskId = true && (isSetTaskId());
    list.add(present_taskId);
    if (present_taskId)
      list.add(taskId);

    boolean present_taskName = true && (isSetTaskName());
    list.add(present_taskName);
    if (present_taskName)
      list.add(taskName);

    boolean present_className = true && (isSetClassName());
    list.add(present_className);
    if (present_className)
      list.add(className);

    boolean present_method = true && (isSetMethod());
    list.add(present_method);
    if (present_method)
      list.add(method);

    boolean present_moduleCode = true && (isSetModuleCode());
    list.add(present_moduleCode);
    if (present_moduleCode)
      list.add(moduleCode);

    boolean present_priority = true && (isSetPriority());
    list.add(present_priority);
    if (present_priority)
      list.add(priority);

    boolean present_isConcurrent = true && (isSetIsConcurrent());
    list.add(present_isConcurrent);
    if (present_isConcurrent)
      list.add(isConcurrent);

    boolean present_taskState = true && (isSetTaskState());
    list.add(present_taskState);
    if (present_taskState)
      list.add(taskState);

    boolean present_lastExecuteTime = true && (isSetLastExecuteTime());
    list.add(present_lastExecuteTime);
    if (present_lastExecuteTime)
      list.add(lastExecuteTime);

    boolean present_nextExcuteDate = true && (isSetNextExcuteDate());
    list.add(present_nextExcuteDate);
    if (present_nextExcuteDate)
      list.add(nextExcuteDate);

    boolean present_operatorId = true && (isSetOperatorId());
    list.add(present_operatorId);
    if (present_operatorId)
      list.add(operatorId);

    boolean present_createTime = true && (isSetCreateTime());
    list.add(present_createTime);
    if (present_createTime)
      list.add(createTime);

    return list.hashCode();
  }

  @Override
  public int compareTo(Task other) {
    if (!getClass().equals(other.getClass())) {
      return getClass().getName().compareTo(other.getClass().getName());
    }

    int lastComparison = 0;

    lastComparison = Boolean.valueOf(isSetTaskId()).compareTo(other.isSetTaskId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetTaskId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.taskId, other.taskId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetTaskName()).compareTo(other.isSetTaskName());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetTaskName()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.taskName, other.taskName);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetClassName()).compareTo(other.isSetClassName());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetClassName()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.className, other.className);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetMethod()).compareTo(other.isSetMethod());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetMethod()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.method, other.method);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetModuleCode()).compareTo(other.isSetModuleCode());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetModuleCode()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.moduleCode, other.moduleCode);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetPriority()).compareTo(other.isSetPriority());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetPriority()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.priority, other.priority);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetIsConcurrent()).compareTo(other.isSetIsConcurrent());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetIsConcurrent()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.isConcurrent, other.isConcurrent);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetTaskState()).compareTo(other.isSetTaskState());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetTaskState()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.taskState, other.taskState);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetLastExecuteTime()).compareTo(other.isSetLastExecuteTime());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetLastExecuteTime()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.lastExecuteTime, other.lastExecuteTime);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetNextExcuteDate()).compareTo(other.isSetNextExcuteDate());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetNextExcuteDate()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.nextExcuteDate, other.nextExcuteDate);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetOperatorId()).compareTo(other.isSetOperatorId());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetOperatorId()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.operatorId, other.operatorId);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    lastComparison = Boolean.valueOf(isSetCreateTime()).compareTo(other.isSetCreateTime());
    if (lastComparison != 0) {
      return lastComparison;
    }
    if (isSetCreateTime()) {
      lastComparison = org.apache.thrift.TBaseHelper.compareTo(this.createTime, other.createTime);
      if (lastComparison != 0) {
        return lastComparison;
      }
    }
    return 0;
  }

  public _Fields fieldForId(int fieldId) {
    return _Fields.findByThriftId(fieldId);
  }

  public void read(org.apache.thrift.protocol.TProtocol iprot) throws org.apache.thrift.TException {
    schemes.get(iprot.getScheme()).getScheme().read(iprot, this);
  }

  public void write(org.apache.thrift.protocol.TProtocol oprot) throws org.apache.thrift.TException {
    schemes.get(oprot.getScheme()).getScheme().write(oprot, this);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder("Task(");
    boolean first = true;

    if (isSetTaskId()) {
      sb.append("taskId:");
      sb.append(this.taskId);
      first = false;
    }
    if (!first) sb.append(", ");
    sb.append("taskName:");
    if (this.taskName == null) {
      sb.append("null");
    } else {
      sb.append(this.taskName);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("className:");
    if (this.className == null) {
      sb.append("null");
    } else {
      sb.append(this.className);
    }
    first = false;
    if (!first) sb.append(", ");
    sb.append("method:");
    if (this.method == null) {
      sb.append("null");
    } else {
      sb.append(this.method);
    }
    first = false;
    if (isSetModuleCode()) {
      if (!first) sb.append(", ");
      sb.append("moduleCode:");
      if (this.moduleCode == null) {
        sb.append("null");
      } else {
        sb.append(this.moduleCode);
      }
      first = false;
    }
    if (isSetPriority()) {
      if (!first) sb.append(", ");
      sb.append("priority:");
      sb.append(this.priority);
      first = false;
    }
    if (isSetIsConcurrent()) {
      if (!first) sb.append(", ");
      sb.append("isConcurrent:");
      if (this.isConcurrent == null) {
        sb.append("null");
      } else {
        sb.append(this.isConcurrent);
      }
      first = false;
    }
    if (isSetTaskState()) {
      if (!first) sb.append(", ");
      sb.append("taskState:");
      if (this.taskState == null) {
        sb.append("null");
      } else {
        sb.append(this.taskState);
      }
      first = false;
    }
    if (isSetLastExecuteTime()) {
      if (!first) sb.append(", ");
      sb.append("lastExecuteTime:");
      sb.append(this.lastExecuteTime);
      first = false;
    }
    if (isSetNextExcuteDate()) {
      if (!first) sb.append(", ");
      sb.append("nextExcuteDate:");
      sb.append(this.nextExcuteDate);
      first = false;
    }
    if (isSetOperatorId()) {
      if (!first) sb.append(", ");
      sb.append("operatorId:");
      sb.append(this.operatorId);
      first = false;
    }
    if (isSetCreateTime()) {
      if (!first) sb.append(", ");
      sb.append("createTime:");
      sb.append(this.createTime);
      first = false;
    }
    sb.append(")");
    return sb.toString();
  }

  public void validate() throws org.apache.thrift.TException {
    // check for required fields
    if (taskName == null) {
      throw new org.apache.thrift.protocol.TProtocolException("Required field 'taskName' was not present! Struct: " + toString());
    }
    if (className == null) {
      throw new org.apache.thrift.protocol.TProtocolException("Required field 'className' was not present! Struct: " + toString());
    }
    if (method == null) {
      throw new org.apache.thrift.protocol.TProtocolException("Required field 'method' was not present! Struct: " + toString());
    }
    // check for sub-struct validity
  }

  private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {
    try {
      write(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(out)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private void readObject(java.io.ObjectInputStream in) throws java.io.IOException, ClassNotFoundException {
    try {
      // it doesn't seem like you should have to do this, but java serialization is wacky, and doesn't call the default constructor.
      __isset_bitfield = 0;
      read(new org.apache.thrift.protocol.TCompactProtocol(new org.apache.thrift.transport.TIOStreamTransport(in)));
    } catch (org.apache.thrift.TException te) {
      throw new java.io.IOException(te);
    }
  }

  private static class TaskStandardSchemeFactory implements SchemeFactory {
    public TaskStandardScheme getScheme() {
      return new TaskStandardScheme();
    }
  }

  private static class TaskStandardScheme extends StandardScheme<Task> {

    public void read(org.apache.thrift.protocol.TProtocol iprot, Task struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // TASK_ID
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.taskId = iprot.readI32();
              struct.setTaskIdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // TASK_NAME
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.taskName = iprot.readString();
              struct.setTaskNameIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // CLASS_NAME
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.className = iprot.readString();
              struct.setClassNameIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // METHOD
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.method = iprot.readString();
              struct.setMethodIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // MODULE_CODE
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.moduleCode = iprot.readString();
              struct.setModuleCodeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // PRIORITY
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.priority = iprot.readI32();
              struct.setPriorityIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 7: // IS_CONCURRENT
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.isConcurrent = iprot.readString();
              struct.setIsConcurrentIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 8: // TASK_STATE
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.taskState = iprot.readString();
              struct.setTaskStateIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 9: // LAST_EXECUTE_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.lastExecuteTime = iprot.readI64();
              struct.setLastExecuteTimeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 10: // NEXT_EXCUTE_DATE
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.nextExcuteDate = iprot.readI64();
              struct.setNextExcuteDateIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 11: // OPERATOR_ID
            if (schemeField.type == org.apache.thrift.protocol.TType.I32) {
              struct.operatorId = iprot.readI32();
              struct.setOperatorIdIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 12: // CREATE_TIME
            if (schemeField.type == org.apache.thrift.protocol.TType.I64) {
              struct.createTime = iprot.readI64();
              struct.setCreateTimeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      struct.validate();
    }

    public void write(org.apache.thrift.protocol.TProtocol oprot, Task struct) throws org.apache.thrift.TException {
      struct.validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (struct.isSetTaskId()) {
        oprot.writeFieldBegin(TASK_ID_FIELD_DESC);
        oprot.writeI32(struct.taskId);
        oprot.writeFieldEnd();
      }
      if (struct.taskName != null) {
        oprot.writeFieldBegin(TASK_NAME_FIELD_DESC);
        oprot.writeString(struct.taskName);
        oprot.writeFieldEnd();
      }
      if (struct.className != null) {
        oprot.writeFieldBegin(CLASS_NAME_FIELD_DESC);
        oprot.writeString(struct.className);
        oprot.writeFieldEnd();
      }
      if (struct.method != null) {
        oprot.writeFieldBegin(METHOD_FIELD_DESC);
        oprot.writeString(struct.method);
        oprot.writeFieldEnd();
      }
      if (struct.moduleCode != null) {
        if (struct.isSetModuleCode()) {
          oprot.writeFieldBegin(MODULE_CODE_FIELD_DESC);
          oprot.writeString(struct.moduleCode);
          oprot.writeFieldEnd();
        }
      }
      if (struct.isSetPriority()) {
        oprot.writeFieldBegin(PRIORITY_FIELD_DESC);
        oprot.writeI32(struct.priority);
        oprot.writeFieldEnd();
      }
      if (struct.isConcurrent != null) {
        if (struct.isSetIsConcurrent()) {
          oprot.writeFieldBegin(IS_CONCURRENT_FIELD_DESC);
          oprot.writeString(struct.isConcurrent);
          oprot.writeFieldEnd();
        }
      }
      if (struct.taskState != null) {
        if (struct.isSetTaskState()) {
          oprot.writeFieldBegin(TASK_STATE_FIELD_DESC);
          oprot.writeString(struct.taskState);
          oprot.writeFieldEnd();
        }
      }
      if (struct.isSetLastExecuteTime()) {
        oprot.writeFieldBegin(LAST_EXECUTE_TIME_FIELD_DESC);
        oprot.writeI64(struct.lastExecuteTime);
        oprot.writeFieldEnd();
      }
      if (struct.isSetNextExcuteDate()) {
        oprot.writeFieldBegin(NEXT_EXCUTE_DATE_FIELD_DESC);
        oprot.writeI64(struct.nextExcuteDate);
        oprot.writeFieldEnd();
      }
      if (struct.isSetOperatorId()) {
        oprot.writeFieldBegin(OPERATOR_ID_FIELD_DESC);
        oprot.writeI32(struct.operatorId);
        oprot.writeFieldEnd();
      }
      if (struct.isSetCreateTime()) {
        oprot.writeFieldBegin(CREATE_TIME_FIELD_DESC);
        oprot.writeI64(struct.createTime);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

  }

  private static class TaskTupleSchemeFactory implements SchemeFactory {
    public TaskTupleScheme getScheme() {
      return new TaskTupleScheme();
    }
  }

  private static class TaskTupleScheme extends TupleScheme<Task> {

    @Override
    public void write(org.apache.thrift.protocol.TProtocol prot, Task struct) throws org.apache.thrift.TException {
      TTupleProtocol oprot = (TTupleProtocol) prot;
      oprot.writeString(struct.taskName);
      oprot.writeString(struct.className);
      oprot.writeString(struct.method);
      BitSet optionals = new BitSet();
      if (struct.isSetTaskId()) {
        optionals.set(0);
      }
      if (struct.isSetModuleCode()) {
        optionals.set(1);
      }
      if (struct.isSetPriority()) {
        optionals.set(2);
      }
      if (struct.isSetIsConcurrent()) {
        optionals.set(3);
      }
      if (struct.isSetTaskState()) {
        optionals.set(4);
      }
      if (struct.isSetLastExecuteTime()) {
        optionals.set(5);
      }
      if (struct.isSetNextExcuteDate()) {
        optionals.set(6);
      }
      if (struct.isSetOperatorId()) {
        optionals.set(7);
      }
      if (struct.isSetCreateTime()) {
        optionals.set(8);
      }
      oprot.writeBitSet(optionals, 9);
      if (struct.isSetTaskId()) {
        oprot.writeI32(struct.taskId);
      }
      if (struct.isSetModuleCode()) {
        oprot.writeString(struct.moduleCode);
      }
      if (struct.isSetPriority()) {
        oprot.writeI32(struct.priority);
      }
      if (struct.isSetIsConcurrent()) {
        oprot.writeString(struct.isConcurrent);
      }
      if (struct.isSetTaskState()) {
        oprot.writeString(struct.taskState);
      }
      if (struct.isSetLastExecuteTime()) {
        oprot.writeI64(struct.lastExecuteTime);
      }
      if (struct.isSetNextExcuteDate()) {
        oprot.writeI64(struct.nextExcuteDate);
      }
      if (struct.isSetOperatorId()) {
        oprot.writeI32(struct.operatorId);
      }
      if (struct.isSetCreateTime()) {
        oprot.writeI64(struct.createTime);
      }
    }

    @Override
    public void read(org.apache.thrift.protocol.TProtocol prot, Task struct) throws org.apache.thrift.TException {
      TTupleProtocol iprot = (TTupleProtocol) prot;
      struct.taskName = iprot.readString();
      struct.setTaskNameIsSet(true);
      struct.className = iprot.readString();
      struct.setClassNameIsSet(true);
      struct.method = iprot.readString();
      struct.setMethodIsSet(true);
      BitSet incoming = iprot.readBitSet(9);
      if (incoming.get(0)) {
        struct.taskId = iprot.readI32();
        struct.setTaskIdIsSet(true);
      }
      if (incoming.get(1)) {
        struct.moduleCode = iprot.readString();
        struct.setModuleCodeIsSet(true);
      }
      if (incoming.get(2)) {
        struct.priority = iprot.readI32();
        struct.setPriorityIsSet(true);
      }
      if (incoming.get(3)) {
        struct.isConcurrent = iprot.readString();
        struct.setIsConcurrentIsSet(true);
      }
      if (incoming.get(4)) {
        struct.taskState = iprot.readString();
        struct.setTaskStateIsSet(true);
      }
      if (incoming.get(5)) {
        struct.lastExecuteTime = iprot.readI64();
        struct.setLastExecuteTimeIsSet(true);
      }
      if (incoming.get(6)) {
        struct.nextExcuteDate = iprot.readI64();
        struct.setNextExcuteDateIsSet(true);
      }
      if (incoming.get(7)) {
        struct.operatorId = iprot.readI32();
        struct.setOperatorIdIsSet(true);
      }
      if (incoming.get(8)) {
        struct.createTime = iprot.readI64();
        struct.setCreateTimeIsSet(true);
      }
    }
  }

}

